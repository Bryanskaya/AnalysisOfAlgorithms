\section{Выбранный язык программирования}
\qquadДля выполнения этой лабораторной работы был выбран язык программирования C++, так как есть большой навык работы с ним и с подключаемыми библиотеками, которые также использовались для проведения тестирования и замеров.\\

Использованная среда разработки - Visual Studio.

\section{Листинг кода}
\qquadНиже представлены Листиги 3.1 - 3.3 функций, реализующих сортировку массива.
\begin{lstlisting}[label=code, caption = Сортировка пузырьком]
#pragma optimize("", off)

void bubble_sort(array_t& arr, int n)
{
	double temp;
	
	for (int i = 0; i < n; i++)
		for (int j = 0; j < n - 1 - i; j++)
			if (arr[j] > arr[j + 1])
			{
				temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
}

#pragma optimize("", on)
\end{lstlisting}

\begin{lstlisting}[label=code, caption = Сортировка вставками]
#pragma optimize("", off)

void insert_sort(array_t& arr, int n)
{
	double temp;
	int k;
	
	for (int i = 1; i < n; i++)
	{
		temp = arr[i];
		k = 0;
		
		while (arr[k] < temp)
		k += 1;
		
		for (int j = i; j > k; j--)
			arr[j] = arr[j - 1];
		
		arr[k] = temp;
	}
}
#pragma optimize("", on)
\end{lstlisting}

\begin{lstlisting}[label=code, caption = Поразрядная сортировка]
#pragma optimize("", off)

int* create_digit(int n)
{
	int* arr = create_array(n);
	int elem = 1;
	
	for (int i = 0; i < n; i++, elem *= 10)
		arr[i] = elem;
	
	return arr;
}

int count_rank(int num)
{
	int count = 0;
	
	while (num > 0)
	{
		count++;
		num /= 10;
	}
	
	return count;
}

int analyze_arr(array_t arr, int n, int& flag)
{
	int min_elem = arr[0], max_elem = min_elem, elem;
	
	for (int i = 1; i < n; i++)
	{
		elem = arr[i];
		if (elem > max_elem)
			max_elem = elem;
		if (elem < min_elem)
			min_elem = elem;
	}
	
	if (min_elem < 0)
	{
		max_elem -= min_elem;
		flag = -min_elem;
		
		for (int i = 0; i < n; i++)
			arr[i] -= min_elem;
	}
	
	return count_rank(max_elem);
}

int get_digit(int num, int i, int* digit)
{
	num %= digit[i + 1];
	num /= digit[i];
	
	return num;
}

void lsd_sort(array_t& arr, int n)
{
	int flag = 0, count, temp, d;
	int rank = analyze_arr(arr, n, flag);
	int* degree_10 = create_digit(rank + 1);
	int num_fig[10];
	array_t temp_res = create_array(n), temp_copy;
	
	for (int i = 0; i < rank; i++)
	{
		for (int j = 0; j < 10; j++)
			num_fig[j] = 0;
		
		for (int j = 0; j < n; j++)
			num_fig[get_digit(arr[j], i, degree_10)]++;
		
		count = 0;
		
		for (int j = 0; j < 10; j++)
		{
			temp = num_fig[j];
			num_fig[j] = count;
			count += temp;
		}
		
		for (int j = 0; j < n; j++)
		{
			d = get_digit(arr[j], i, degree_10);
			temp_res[num_fig[d]] = arr[j];
			num_fig[d]++;
		}
		
		temp_copy = arr;
		arr = temp_res;
		temp_res = temp_copy;
	}
	
	free_array(&degree_10);
	free_array(&temp_res);
	
	if (flag)
		for (int i = 0; i < n; i++)
			arr[i] -= flag;
}

#pragma optimize("", on)
\end{lstlisting}

\section{Результаты тестов}
\qquadДля тестирования были написаны функции, проверяющие, согласно заготовкам выше, случаи. Выводы о корректности работы делаются на основе сравнения результатов.\\

\textbf{Все тесты пройдены успешно.} Сами тесты представлены ниже (Листинг 3.4).\\

\begin{lstlisting}[label=code, caption = Тесты]
bool sort_cmp(array_t a, int n)
{
	bool res = true;
	void(*func_arr[])(array_t&, int) = { bubble_sort, insert_sort, lsd_sort };
	
	array_t c = copy_array(a, n);
	sort(c, c + n);
	
	for (int i = 0; i < 3 && res; i++)
	{
		array_t temp_arr = copy_array(a, n);
		
		(*func_arr[i])(temp_arr, n);
		
		res = cmp_array(c, temp_arr, n);
		
		free_array(&temp_arr);
	}
	
	free_array(&c);
	
	return res;
}

// Размер массива равен 1
void test_size_1()
{
	int n = 1;
	
	for (int i = 0; i < 3; i++)
	{
		array_t a = random_fill_array(n);
		
		if (!sort_cmp(a, n))
		{
			cout << endl << __FUNCTION__ << " FAILED" << endl;
			free_array(&a);
			return;
		}
		
		free_array(&a);
	}
	
	cout << endl << __FUNCTION__ << " OK" << endl;
}

// Произвольные массивы различный длин
void test_std()
{
	int n[] = { 3, 5, 8, 10, 12 };
	
	for (int i = 0; i < sizeof(n)/sizeof(n[0]); i++)
	{
		array_t a = random_fill_array(n[i]);
		
		if (!sort_cmp(a, n[i]))
		{
			cout << endl << __FUNCTION__ << " FAILED" << endl;
			free_array(&a);
			return;
		}
		
		free_array(&a);
	}
	
	cout << endl << __FUNCTION__ << " OK" << endl;
}

// Уже отсортированные по неубыванию массивы
void test_sorted()
{
	int n = 30;
	
	array_t a = random_fill_array(n);
	
	sort(a, a + n);
	
	if (!sort_cmp(a, n))
	{
		cout << endl << __FUNCTION__ << " FAILED" << endl;
		free_array(&a);
		return;
	}
	
	free_array(&a);
	
	cout << endl << __FUNCTION__ << " OK" << endl;
}

// Уже отсортированные по невозрастанию массивы
void test_reverse_sorted()
{
	int n = 30;
	
	array_t a = random_fill_array(n);
	
	sort(a, a + n);
	reverse(a, a + n);
	
	if (!sort_cmp(a, n))
	{
		cout << endl << __FUNCTION__ << " FAILED" << endl;
		free_array(&a);
		return;
	}
	
	free_array(&a);
	
	cout << endl << __FUNCTION__ << " OK" << endl;
}

// Массив одинаковых элементов
void test_same_elements()
{
	int n = 30;
	array_t a = create_array(n);
	
	for (int i = 0; i < n; i++)
		a[i] = 102;
	
	if (!sort_cmp(a, n))
	{
		cout << endl << __FUNCTION__ << " FAILED" << endl;
		free_array(&a);
		return;
	}
	
	free_array(&a);
	
	cout << endl << __FUNCTION__ << " OK" << endl;
}

void run_tests()
{
	test_size_1();
	test_std();
	test_sorted();
	test_reverse_sorted();
	test_same_elements();
}
\end{lstlisting}

\section{Оценка трудоёмкости}
\qquadПроизведём оценку трудоёмкости приведённых алгоритмов. Рассмотрим сортировку массива  $A[N]$.\\

\section{Оценка времени}
\qquadПроцессорное время измеряется с помощью функции QueryPerformanceCounter библиотеки windows.h \cite{Query}. Осуществление замеров показано ниже (Листинг 3.5).
\begin{lstlisting}[label=code, caption = Замеры процессорного времени]
	
\end{lstlisting}