\documentclass[12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{setspace} % для междустрочного интервала
\onehalfspacing % 1.5 интервал между строками

\usepackage{graphicx}
\graphicspath{{pictures/}}

\usepackage[left=30mm, top=20mm, right=20mm, bottom=20mm, nohead, footskip=7mm]{geometry}

\usepackage{listings}

\lstset{
language = python,
basicstyle=\small\sffamily,
numbers=left,
numberstyle=\tiny,
stepnumber=1,
numbersep=5pt,
showspaces=false,
showstringspaces=false,
showtabs=false,
frame=single,
tabsize=2,
captionpos=t,
breaklines=true,
breakatwhitespace=false,
escapeinside={\#*}{*)}
}


\usepackage{titlesec, blindtext, color} 
\definecolor{gray75}{gray}{0.75}
\newcommand{\hsp}{\hspace{20pt}}
\titleformat{\chapter}[hang]{\huge\bfseries}{\thechapter\hsp\textcolor{gray75}{}\hsp}{0pt}{\huge\bfseries}
\titlespacing{\chapter}{0pt}{-30pt}{12pt} % отступ заголовка сверху


\begin{document}

лаб01


\tableofcontents

\newpage
\chapter*{Введение}
\addcontentsline{toc}{chapter}{Введение}

\textbf{Расстояние Левенштейна}  (рациональное расстояние) – это минимальное количество редакторских операций, которые необходимы для превращения одной строки в другую. 

Под редакторскими операциями подразумеваются:
\begin{itemize}
\item вставка (обозначается, как I - insert);
\item замена (R - replace);
\item удаление (D - delete);
\item также сюда относится совпадение (M - match).
\end{itemize}

Расстояние Левенштейна имеет широкий спектр применения, например, используется в поисковых строках, в программах, отвечающих за автоисправление, автозамену. Помимо этого, оно также применяется в биоинформатике (строение белков представляется строками, состоящими из букв ограниченного алфавита, таким образом, упрощается их анализ).

Существует много алгоритмов, рассчитывающих расстояние Левенштейна, а также их модификаций, которые и будут рассмотрены далее.


\chapter{Аналитическая часть}
\textbf{Цель} данной работы – реализовать и сравнить алгоритмы поиска расстояний Левенштейна и Дамерау-Левенштейна.\\

Для достижения поставленной цели необходимо решить ряд следующих \textbf{задач}:
\begin{enumerate}
\item дать математическое описание расстояний;
\item описать алгоритмы поиска расстояний;
\item оценить затрачиваемую алгоритмами память;
\item реализовать эти алгоритмы ;
\item провести замеры процессорного времени работы алгоритмов на материале серии экспериментов;
\item провести сравнительный анализ алгоритмов.
\end{enumerate}

Поиск расстояния Левенштейна можно описать разными алгоритмами:
\begin{itemize}
\item матричный расчёт;
\item рекурсивный расчёт по формуле;
\item рекурсивный алгоритм, заполняющий незаполненные клетки матрицы.
\end{itemize}

Пусть S1 и S2 – строки длиной N и M соответственно. Тогда расстояние Левенштейна можно рассчитать по следующей рекуррентной формуле:

\begin{equation}
D(i,j) = \left\{ \begin{array}{ll}
 j, & \textrm{$\mbox{если }i = 0$}\\
 i, & \textrm{$\mbox{если }j = 0, i > 0$}\\
min(D(S1[1..i], S2[1.. j - 1])+1,\\
\qquad D(S1[1..i - 1], S2[1..j]) + 1, &\textrm{$\mbox{если }i>0, j>0$}\\
\qquad D(S1[1..i - 1], S2[1..j - 1]) + \\
\qquad+\left[ 
	\begin{array}{ccc}
	0, & \textrm{$\mbox{если }S1[i] == S2[j],)$}\\
	1, & \textrm{иначе}
	\end{array} 
\right.
  \end{array} \right.
\end{equation}

При таком способе расчёта расстояния нужно использовать матрицу размера Len(S1) + 1 x Len(S2) + 1, элементы которого рассчитываются по формуле выше.\\

Что касается \textbf{рекурсивного расчёта}, то возникает проблема большого количества повторных вычислений. Это очень сильно влияет как на время выполнения, так и на занимаемую память.\\

\textbf{Рекурсивный алгоритм, заполняющий незаполненные клетки матрицы,} работает по аналогии с бесконечностями в алгоритме Дейкстры поиска расстояний в графе.\\

\textbf{Расстояние Дамерау-Левенштейна} дополнительно включает операцию перестановки двух соседних символов (транспозицию) и формула выглядит следующим образом:

\begin{equation}
	D(i,j) = \left\{ \begin{array}{ll}
		j, & \textrm{$\mbox{если }i = 0$}\\
		i, & \textrm{$\mbox{если }j = 0, i > 1$}\\ %6554546
		min(D(S1[1..i], S2[1.. j - 1]) + 1,\\
		\qquad D(S1[1..i - 1], S2[1..j]) + 1,\\
		\qquad D(S1[1..i - 1], S2[1..j - 1]) + \\
		\qquad+\left[ 
		\begin{array}{ccc}
			0, & \textrm{$\mbox{если }S1[i] == S2[j],$}\\
			1, & \textrm{иначе}
		\end{array} 
		\right.\\
		\qquad D(S1[1..i], S2[1..j]) + 1), & \textrm{$\mbox{если }i > 1, j > 1,$}\\
		& \textrm{$S1[i] == S2[j - 1],$}\\
		& \textrm{$S1[i - 1] == S2[j]$}\\
		min(D(S1[1..i], S2[1..j - 1]) + 1,\\
		\qquad D(S1[1..i - 1], S2[1..j]) + 1, \\
		\qquad D(S1[1..i - 1], S2[1..j - 1]) + \\
		\qquad+\left[ 
		\begin{array}{ccc}
			0, & \textrm{$\mbox{если }S1[i] == S2[j],$}\\
			1, & \textrm{иначе}
		\end{array} 
		\right.), &\textrm{$\mbox{если }i>0, j>0$}
	\end{array} \right.
\end{equation}

\chapter{Конструкторская часть}

Рассмотрим алгоритмы поиска расстояния Левенштейна и Дамерау-Левенштейна для строк S1, S2, каждая из которых имеет длину N и M соответственно.

\section{Расстояние Левенштейна, матричный алгоритм}
\qquadВ основе этого алгоритма лежит формула (1.2). \\

Задаётся матрица размером (N + 1)x(M + 1). Отдельно обрабатывается тривиальный случай: первая строка и первый столбец. 
Далее компоненты матрицы заполняются по формуле так, что выбирается ход с наименьшей стоимостью. 
Попасть в очередную клетку матрицы можно из левой, верхней и диагональной клеток.\\

Результат вычисления будет находится в ячейке [N - 1][M - 1] (то есть в самом углу справа снизу).\\

\textbf{Схема} алгоритма представлена на Рис. 2.1.

\begin{figure}[h]
	\begin{center}
		{\includegraphics[scale = 1]{LevMatrix}}
		\caption{Матричный алгоритм нахождения расстояния Левенштейна}
	\end{center}
\end{figure}

\section{Расстояние Левенштейна, рекурсивный алгоритм}
\qquadЭтот алгоритм использует рекурсивную формулу для вычисления наименьшего расстояния. \\

На вход подаётся две строки и длины обрабатываемых подстрок i, j, которые в последующем будут рекурсивно изменяться, то есть, (i, j - 1), (i - 1, j - 1), (i - 1, j), до тех пор, пока хотя бы одна из строк не обработается полностью (длина подстроки станет равна нулю). \\

И по завершению работы алгоритмы выбирается наименьшее из трёх полученных значений. \\

\textbf{Схема} алгоритма представлена на Рис. 2.2.

\begin{figure}[h]
	\begin{center}
		{\includegraphics[scale = 0.75]{LevRec}}
		\caption{Рекурсивный расчёт}
	\end{center}
\end{figure}

\section{Расстояние Левенштейна, использующий рекурсию и матрицу}
\qquadПринцип работы этого алгоритма схож с алгоритмом Дейкстры поиска расстояний в графе. \\

Сначала задаётся матрица размером (N + 1)x(M + 1), все её ячейки заполняются значением +{$\infty$}. Элемент [0][0] заполняется 0, с него и будет начинаться работы алгоритма.\\

На вход рекурсивной функции подаётся матрица, индексы i, j, задающие текущее положение и обрабатываемые строки. По ходу выполнения функции делается выбор, в какую следующую клетку стоит перейти из рассматриваемого ([i][j]). Выбор осуществляется так же, как это было в предыдущих алгоритмов: рассматривается три ячейки с индексами [i + 1][j + 1], [i][j + 1], [i + 1][j] и выбирается та, при переходе из которой расстояние будет наименьшим. И уже из неё осуществляется последующий запуск рекурсивной функции. Важно делать дополнительную проверку на то, чтобы соседняя клетка находилась в пределах матрицы.\\

Результат вычисления будет находится в ячейке [N - 1][M - 1] (то есть в самом углу справа снизу).\\

\textbf{Схема} алгоритма представлена на Рис. 2.3.

\begin{figure}[h]
	\begin{center}
		{\includegraphics[scale = 0.61]{MatrRec_part2}}
		\caption{Алгоритм, использующий рекурсию и матрицу}
	\end{center}
\end{figure}

\section{Расстояние Дамерау-Левенштейна}
\qquadВ основе алгоритма лежит формула (1.2). В отличие от предыдущих этот метод нахождения минимального расстояния дополнительно учитывает операцию перестановки двух соседних символов. Такая операция называется \textit{транспозицией}\\

Так как этот алгоритм является модификацией описанного выше метода поиска расстояния Левенштейна, то принцип его работы аналогичен. Также создаётся матрица, отдельно отрабатываются тривиальные случаи, выбирается ход с наименьшей стоимостью, только дополнительно проверяется возможность транспозиции.

Результат также будет находится в ячейке [N - 1][M - 1].\\

\textbf{Схема} алгоритма представлена на Рис. 2.4.

\begin{figure}[h]
	\begin{center}
		{\includegraphics[scale = 0.63]{DanLev}}
		\caption{Алгоритм нахождения расстояния Дамерау-Левенштейна}
	\end{center}
\end{figure}

\section{Требования к ПО}
Для корректной работы алгоритмов и проведения тестов необходимо сделать следующее.
\begin{enumerate}
	\itemОбеспечить возможность ввода двух строк через консоль и выбора алгоритма для расчёта минимального расстояния.
	\itemПрограмма должна рассчитать искомое значение и вывести его на экран, также, если в выбранном методе используется матрица, нужно вывести и её.
	\itemРеализовать функцию замера процессорного времени, которое выбранный метод затрачивает на вычисление результата. Дать возможность пользователю ввести длины рассматриваемых строк через консоль. Вывести результаты замеров на экран.
	\end{enumerate}

\section{Заготовки тестов}
При проверке на корректность работы реализованных функций необходимо провести следующие тесты:
\begin{enumerate}
	\itemобе строки пустые;
	\itemтолько одна из строк пустая;
	\itemполностью совпадающие строки;
	\item
	\item
	\item\item
\end{enumerate}

\chapter{Технологическая часть}
\section{Выбранный язык программирования}
Для выполнения этой лабораторной работы был выбран язык программирования Python, так как есть большой навык работы с ним и с подключаемыми библиотеками, которые также использовались для проведения замеров.
\section{Инструменты замеров}
\section{Листинг}
\begin{lstlisting}[label=some-code, caption = Матричный алгоритм нахождения расстояния Левенштейна]
def LevMatrix(s1, s2):
	n = len(s1) + 1
	m = len(s2) + 1
	
	matrix = [[i + j for j in range(m)] for i in range(n)]
	
	for i in range(1, n):
	for j in range(1, m):
	const = 0 if (s1[i - 1] == s2[j - 1]) else 1
	
	matrix[i][j] = min(matrix[i][j - 1] + 1,
	matrix[i - 1][j] + 1,
	matrix[i - 1][j - 1] + const)
	
	return matrix[n - 1][m - 1]
	
	\end{lstlisting}

\begin{lstlisting}[label=some-code, caption = Расстояние Левенштейна - рекурсивный расчёт по формуле]
def LevRecursion(s1, s2, len1, len2):
	if len1 == 0 or len2 == 0:
		return abs(len1 - len2)
	
	const = 0 if (s1[len1 - 1] == s2[len2 - 1]) else 1
	return min(LevRecursion(s1, s2, len1, len2 - 1) + 1,
			   LevRecursion(s1, s2, len1 - 1, len2 - 1) + const,
			   LevRecursion(s1, s2, len1 - 1, len2) + 1)
\end{lstlisting}

\begin{lstlisting}[label=some-code, caption = Расстояние Левенштейна - алгоритм с рекурсией и матрицей]
def LevMatrixRecursion_process(matrix, i, j, s1, s2):
	if i + 1 < len(matrix) and j + 1 < len(matrix[0]):
		const = 0 if s1[i] == s2[j] else 1
		if matrix[i + 1][j + 1] > matrix[i][j] + const:
			matrix[i + 1][j + 1] = matrix[i][j] + const
			LevMatrixRecursion_process(matrix, i + 1, j + 1, s1, s2)
	
	if j + 1 < len(matrix[0]) and matrix[i][j + 1] > matrix[i][j] + 1:
		matrix[i][j + 1] = matrix[i][j] + 1
		LevMatrixRecursion_process(matrix, i, j + 1, s1, s2)
	
	if i + 1 < len(matrix) and matrix[i + 1][j] > matrix[i][j] + 1:
		matrix[i + 1][j] = matrix[i][j] + 1
		LevMatrixRecursion_process(matrix, i + 1, j, s1, s2)
\end{lstlisting}

\begin{lstlisting}[label=some-code, caption = Расстояние Дамерау-Левенштейна]
	def LevMatrixRecursion_process(matrix, i, j, s1, s2):
	if i + 1 < len(matrix) and j + 1 < len(matrix[0]):
	const = 0 if s1[i] == s2[j] else 1
	if matrix[i + 1][j + 1] > matrix[i][j] + const:
	matrix[i + 1][j + 1] = matrix[i][j] + const
	LevMatrixRecursion_process(matrix, i + 1, j + 1, s1, s2)
	
	if j + 1 < len(matrix[0]) and matrix[i][j + 1] > matrix[i][j] + 1:
	matrix[i][j + 1] = matrix[i][j] + 1
	LevMatrixRecursion_process(matrix, i, j + 1, s1, s2)
	
	if i + 1 < len(matrix) and matrix[i + 1][j] > matrix[i][j] + 1:
	matrix[i + 1][j] = matrix[i][j] + 1
	LevMatrixRecursion_process(matrix, i + 1, j, s1, s2)
\end{lstlisting}



\chapter{Исследовательская часть}
\chapter*{Заключение}
\addcontentsline{toc}{chapter}{Заключение}


\end{document}