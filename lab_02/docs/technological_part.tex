\section{Выбранный язык программирования}
\qquadДля выполнения этой лабораторной работы был выбран язык программирования C++, так как есть большой навык работы с ним и с подключаемыми библиотеками, которые также использовались для проведения тестирования и замеров.\\

Использованная среда разработки - Visual Studio.

\section{Листинг кода}
\qquadНиже представлены Листиги 3.1 - 3.3 функций, реализующих алгоритмы поиска расстояний.
\begin{lstlisting}[label=code, caption = Стандартный алгоритм умножения матриц]
	matrix_t standart_mult(matrix_t a, matrix_t b, int m, int n, int q)
	{
		matrix_t c = create_matrix(m, q);
		
		for (int i = 0; i < m; i++)
			for (int j = 0; j < q; j++)
			{
				c[i][j] = 0;
				for (int k = 0; k < n; k++)
					c[i][j] += a[i][k] * b[k][j];
			}
		
		return c;
	}
\end{lstlisting}

\begin{lstlisting}[label=code, caption = Алгоритм Винограда]
matrix_t winograd_mult(matrix_t a, matrix_t b, int m, int n, int q)
{
	arr_t mulH = create_array(m);
	arr_t mulV = create_array(n);
	matrix_t c = create_matrix(m, q);
	
	for (int i = 0; i < m; i++)
	{
		mulH[i] = 0;
		for (int k = 0; k < n / 2; k++)
			mulH[i] = mulH[i] + a[i][2 * k] * a[i][2 * k + 1];
	}
	
	for (int i = 0; i < q; i++)
	{
		mulV[i] = 0;
		for (int k = 0; k < n / 2; k++)
			
			mulV[i] = mulV[i] + b[2 * k][i] * b[2 * k + 1][i];
	}
	
	for (int i = 0; i < m; i++)
		for (int j = 0; j < q; j++)
		{
			c[i][j] = -mulH[i] - mulV[j];
			for (int k = 0; k < n / 2; k++)
				c[i][j] = c[i][j] + (a[i][2 * k] + b[2 * k + 1][j]) * 
						  		(a[i][2 * k + 1] + b[2 * k][j]);
		}
	
	if (n % 2)
		for (int i = 0; i < m; i++)
			for (int j = 0; j < q; j++)
				c[i][j] = c[i][j] + a[i][n - 1] * b[n - 1][j];
	
	return c;
}
\end{lstlisting}

\begin{lstlisting}[label=code, caption = Оптимизированный алгоритм Винограда]
matrix_t winograd_mult(matrix_t a, matrix_t b, int m, int n, int q)
{
	arr_t mulH = create_array(m);
	arr_t mulV = create_array(n);
	double buf;
	
	matrix_t c = create_matrix(m, q);
	
	for (int i = 0; i < m; i++)
	{
		buf = 0;
		for (int k = 1; k < n; k += 2)
			buf += a[i][k] * a[i][k - 1];
		mulH[i] = buf;
	}
	
	for (int i = 0; i < q; i++)
	{
		buf = 0;
		for (int k = 1; k < n; k += 2)
			buf += b[k][i] * b[k - 1][i];
		mulV[i] = buf;
	}
	
	int temp = n - 1;
	
	for (int i = 0; i < m; i++)
		for (int j = 0; j < q; j++)
		{
			buf = -(mulH[i] + mulV[j]);
			for (int k = 1, t = 0; k < n; k += 2, t +=2)
				buf += (a[i][k] + b[t][j]) * (a[i][t] + b[k][j]);
			c[i][j] = buf;
			
			if (n % 2)
				c[i][j] += a[i][temp] * b[temp][j];
		}
	
	return c;
}
\end{lstlisting}

\section{Оптимизации алгоритма Винограда}
\qquadЧтобы уменьшить трудоёмкость  алгоритма были использованы следующие оптимизации.
\begin{enumerate}
	\item[1)]Видоизменён цикл по k, изменён шаг и условие. Таким образом, ушла необходимость в целочисленном делении, и в теле цикла не требуется больше умножать k на 2 каждый раз.
	\item[2)]Введена вспомогательная переменная buf, в которую записывается промежуточнее значение соответсвующей ячейки матрицы, и затем, конечный результат переносится в саму матрицу. Тем самым, уменьшается количество обращений к элементам матрицы, находящимся по конкретному адресу.
	\item[3)]Заранее высчитываются некоторые значения, например, n - 1, которые далее используюся во вложенных циклах.
	\item[4)]Используется дополнительная переменная t = k - 1, чтобы сократить число подсчетов этого значения на каждом шаге цикла. 
	\item[5)]Объединён цикл 3 и 4, что позволило избежать ещё одного сложенного цикла.
\end{enumerate}

\section{Результаты тестов}


\section{Оценка трудоёмкости}

\section{Оценка времени}